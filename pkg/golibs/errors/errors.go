// Copyright 2023 The acquirecloud Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package errors

import (
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"strings"

	"github.com/dspasibenko/twin-go/pkg/golibs/cast"
)

// It is proposed to form the general class of errors that could be used in wider cases and cover
// very general scenarios to analyze on entry levels like API endpoints. For example, an object or
// resource may not exist, but this can be reported in different forms and indirect error responses,
// that could be generalized like ErrNotExist, for example:
// err := thirdPartyService.Call()
//
//	if err != nil && strconv.Contain(err.String(), "not found") {
//			return fmt.Errorf("the tird party response %q: %w", err.String(), errors.ErrNotExist)
//	}
//
// also, gRPC has code-based error encoding and some helper functions may help to pass
// the general error over the network:
// Service A:
//
//	func RemoteCall() {
//	  ...
//	  return response, GRPCWrap(err)
//	}
//
// The service A client:
//
//	...
//	resp, err := serviceA.RemoteCall()
//	if errors.Is(err, errorsErrInvalid) { // this error comes from the remote service
//	   ...
//	}
var (
	// ErrExist - the error is in the acquire cloud namespace, it covers the wider
	// class objects including os.ErrExist (fs.ErrExist)
	ErrExist = os.ErrExist
	// ErrNotExist - the error is in the acquire cloud namespace, it covers the wider
	// class objects including os.ErrNotExist (fs.ErrNotExist)
	ErrNotExist = os.ErrNotExist
	// ErrClosed - the error is in the acquire cloud namespace, it covers the wider
	// class objects including os.ErrClosed (fs.ErrClosed)
	ErrClosed = os.ErrClosed
	// ErrInvalid indicates that the passed data has not accepted format and
	// cannot be processed due to violation of some contract
	ErrInvalid = os.ErrInvalid
	// ErrNotAuthorized - the error is in the acquire cloud namespace, and it's returned when
	// permission is denied for user to access requested action
	ErrNotAuthorized = os.ErrPermission
	// DataLoss indicates unrecoverable data loss or corruption. The error may
	// be reported when the data is "partially" changed and the changes may not be
	// rolled back.
	ErrDataLoss = fmt.Errorf("data loss")
	// ErrCommunication - the error indicates any problem with the components' communication
	// in the distributed system
	ErrCommunication = fmt.Errorf("system communication error")
	// ErrInternal - any error which doesn't covered by other class of errors provided here
	ErrInternal = fmt.Errorf("internal system error")
	// ErrConflict - the error indicates any problem related to data or request conflict,
	// for instance, version conflict
	ErrConflict = fmt.Errorf("conflict")
	// ErrExhausted - the error indicates that the request or response entity is larger than
	// limits defined by the server. The error also may indicate that some resource has been
	// exhausted, perhaps a per-user quota, or perhaps the entire file system is out of space.
	//
	// This error code will be generated by controlable out-of-memory and server overload
	// situations, or when a message is larger than the configured maximum size.
	ErrExhausted = fmt.Errorf("too large")
	// Unimplemented indicates operation is not implemented or not supported/enabled in this
	// function/service.
	ErrUnimplemented = fmt.Errorf("unimplemented")
	// ErrCanceled indicates that the execution was cancelled
	ErrCanceled = fmt.Errorf("canceled")
)

// Is reports whether any error in err's chain matches target, OR
// corresponds to the target.
func Is(err, target error) bool {
	if errors.Is(err, target) {
		return true
	}
	return false
}

const jsonErrorMarker = "\x1bjson"

// EmbedObject allows to add json-marshaled version of the object o into the error err and returns the new error. The
// object maybe extracted then from the resulted error by ExgtractObject() function, see below
func EmbedObject(o any, err error) error {
	if o == nil {
		panic("EmbedObject(): non-nil object is expected")
	}
	if err == nil {
		panic("EmbedObject(): non-nil error is expected")
	}
	if strings.Index(err.Error(), jsonErrorMarker) >= 0 {
		panic(fmt.Sprintf("EmbedObject(): the error %q already contains embeddings, cannot add more", err.Error()))
	}
	b, e := json.Marshal(o)
	if e != nil {
		// o is not marshalable, err as is
		return err
	}
	return fmt.Errorf("%s%s%s: %w", jsonErrorMarker, cast.ByteArrayToString(b), jsonErrorMarker, err)
}

// ExtractObject allows to extract value for the object o from the error err if its embedded version is there.
// The function returns the extraction result whether err contains the object value and it was extracted
// successfully or not.
func ExtractObject(err error, o any) bool {
	if err == nil {
		return false
	}
	str := err.Error()
	subs := strings.Split(str, jsonErrorMarker)
	if len(subs) != 3 {
		// we expect two markers in the str, otherwise it is malformed or no objects...
		return false
	}
	return json.Unmarshal(cast.StringToByteArray(subs[1]), o) == nil
}
